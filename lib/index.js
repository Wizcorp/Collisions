!function(_,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.collisions=t():_.collisions=t()}(window,function(){return function(_){var t={};function n(e){if(t[e])return t[e].exports;var s=t[e]={i:e,l:!1,exports:{}};return _[e].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=_,n.c=t,n.d=function(_,t,e){n.o(_,t)||Object.defineProperty(_,t,{enumerable:!0,get:e})},n.r=function(_){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(_,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(_,"__esModule",{value:!0})},n.t=function(_,t){if(1&t&&(_=n(_)),8&t)return _;if(4&t&&"object"==typeof _&&_&&_.__esModule)return _;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:_}),2&t&&"string"!=typeof _)for(var s in _)n.d(e,s,function(t){return _[t]}.bind(null,s));return e},n.n=function(_){var t=_&&_.__esModule?function(){return _.default}:function(){return _};return n.d(t,"a",t),t},n.o=function(_,t){return Object.prototype.hasOwnProperty.call(_,t)},n.p="",n(n.s=0)}([function(_,t,n){"use strict";n.r(t);const e=[];class s{constructor(){this._bvh_parent=null,this._bvh_branch=!0,this._bvh_left=null,this._bvh_right=null,this._bvh_sort=0,this._bvh_min_x=0,this._bvh_min_y=0,this._bvh_max_x=0,this._bvh_max_y=0}static getBranch(){return e.length?e.pop():new s}static releaseBranch(_){e.push(_)}static sortBranches(_,t){return _.sort>t.sort?-1:1}}class i{constructor(){this._hierarchy=null,this._bodies=[],this._dirty_branches=[]}insert(_,t=!1){if(!t){const t=_._bvh;if(t&&t!==this)throw new Error("Body belongs to another collision system");_._bvh=this,this._bodies.push(_)}const n=_._polygon,e=_.x,i=_.y;n&&(_._dirty_coords||_.x!==_._x||_.y!==_._y||_.angle!==_._angle||_.scale_x!==_._scale_x||_.scale_y!==_._scale_y)&&_._calculateCoords();const r=_._bvh_padding,o=n?0:_.radius*_.scale,h=(n?_._min_x:e-o)-r,l=(n?_._min_y:i-o)-r,a=(n?_._max_x:e+o)+r,c=(n?_._max_y:i+o)+r;_._bvh_min_x=h,_._bvh_min_y=l,_._bvh_max_x=a,_._bvh_max_y=c;let b=this._hierarchy,u=0;if(b)for(;;){if(!b._bvh_branch){const t=b._bvh_parent,n=b._bvh_min_x,e=b._bvh_min_y,i=b._bvh_max_x,r=b._bvh_max_y,o=b._bvh_parent=_._bvh_parent=s.getBranch();o._bvh_parent=t,o._bvh_left=b,o._bvh_right=_,o._bvh_sort=u++,o._bvh_min_x=h<n?h:n,o._bvh_min_y=l<e?l:e,o._bvh_max_x=a>i?a:i,o._bvh_max_y=c>r?c:r,t?t._bvh_left===b?t._bvh_left=o:t._bvh_right=o:this._hierarchy=o;break}{const _=b._bvh_left,t=_._bvh_min_y,n=_._bvh_max_x,e=_._bvh_max_y,s=h<_._bvh_min_x?h:_._bvh_min_x,i=l<t?l:t,r=a>n?a:n,o=c>e?c:e,v=(r-s)*(o-i)-(n-_._bvh_min_x)*(e-t),y=b._bvh_right,x=y._bvh_min_x,d=y._bvh_min_y,f=y._bvh_max_x,m=y._bvh_max_y,p=h<x?h:x,g=l<d?l:d,w=a>f?a:f,P=c>m?c:m,M=(w-p)*(P-g)-(f-x)*(m-d);b._bvh_sort=u++,b._bvh_min_x=s<p?s:p,b._bvh_min_y=i<g?i:g,b._bvh_max_x=r>w?r:w,b._bvh_max_y=o>P?o:P,b=v<=M?_:y}}else this._hierarchy=_}remove(_,t=!1){if(!t){const t=_._bvh;if(t&&t!==this)throw new Error("Body belongs to another collision system");_._bvh=null,this._bodies.splice(this._bodies.indexOf(_),1)}if(this._hierarchy===_)return void(this._hierarchy=null);const n=_._bvh_parent,e=n._bvh_parent,i=n._bvh_left,r=i===_?n._bvh_right:i;if(r._bvh_parent=e,r._bvh_branch&&(r._bvh_sort=n._bvh_sort),e){e._bvh_left===n?e._bvh_left=r:e._bvh_right=r;let _=e;for(;_;){const t=_._bvh_left,n=t._bvh_min_x,e=t._bvh_min_y,s=t._bvh_max_x,i=t._bvh_max_y,r=_._bvh_right,o=r._bvh_min_x,h=r._bvh_min_y,l=r._bvh_max_x,a=r._bvh_max_y;_._bvh_min_x=n<o?n:o,_._bvh_min_y=e<h?e:h,_._bvh_max_x=s>l?s:l,_._bvh_max_y=i>a?i:a,_=_._bvh_parent}}else this._hierarchy=r;s.releaseBranch(n)}update(){const _=this._bodies,t=_.length;for(let n=0;n<t;++n){const t=_[n];let e=!1;if(e||t.padding===t._bvh_padding||(t._bvh_padding=t.padding,e=!0),!e){const _=t._polygon;_&&(t._dirty_coords||t.x!==t._x||t.y!==t._y||t.angle!==t._angle||t.scale_x!==t._scale_x||t.scale_y!==t._scale_y)&&t._calculateCoords();const n=t.x,s=t.y,i=_?0:t.radius*t.scale,r=_?t._min_x:n-i,o=_?t._min_y:s-i,h=_?t._max_x:n+i,l=_?t._max_y:s+i;e=r<t._bvh_min_x||o<t._bvh_min_y||h>t._bvh_max_x||l>t._bvh_max_y}e&&(this.remove(t,!0),this.insert(t,!0))}}potentials(_){const t=[],n=_._bvh_min_x,e=_._bvh_min_y,s=_._bvh_max_x,i=_._bvh_max_y;let r=this._hierarchy,o=!0;if(!r||!r._bvh_branch)return t;for(;r;){if(o){o=!1;let _=r._bvh_branch?r._bvh_left:null;for(;_&&_._bvh_max_x>=n&&_._bvh_max_y>=e&&_._bvh_min_x<=s&&_._bvh_min_y<=i;)_=(r=_)._bvh_branch?r._bvh_left:null}const h=r._bvh_branch,l=h?r._bvh_right:null;if(l&&l._bvh_max_x>n&&l._bvh_max_y>e&&l._bvh_min_x<s&&l._bvh_min_y<i)r=l,o=!0;else{h||r===_||t.push(r);let n=r._bvh_parent;if(!n)break;for(;n&&n._bvh_right===r;)n=(r=n)._bvh_parent;r=n}}return t}draw(_){const t=this._bodies,n=t.length;for(let e=0;e<n;++e)t[e].draw(_)}drawBVH(_){let t=this._hierarchy,n=!0;for(;t;){if(n){n=!1;let _=t._bvh_branch?t._bvh_left:null;for(;_;)_=(t=_)._bvh_branch?t._bvh_left:null}const e=t._bvh_branch,s=t._bvh_min_x,i=t._bvh_min_y,r=t._bvh_max_x,o=t._bvh_max_y,h=e?t._bvh_right:null;if(_.moveTo(s,i),_.lineTo(r,i),_.lineTo(r,o),_.lineTo(s,o),_.lineTo(s,i),h)t=h,n=!0;else{let _=t._bvh_parent;if(!_)break;for(;_&&_._bvh_right===t;)_=(t=_)._bvh_parent;t=_}}}}class r{constructor(){this.collision=!1,this.a=null,this.b=null,this.a_in_b=!1,this.b_in_a=!1,this.overlap=0,this.overlap_x=0,this.overlap_y=0}}function o(_,t,n=null,e=!0){const s=_._polygon,i=t._polygon;let r=!1;return n&&(n.a=_,n.b=t,n.a_in_b=!0,n.b_in_a=!0,n.overlap=null,n.overlap_x=0,n.overlap_y=0),s&&(_._dirty_coords||_.x!==_._x||_.y!==_._y||_.angle!==_._angle||_.scale_x!==_._scale_x||_.scale_y!==_._scale_y)&&_._calculateCoords(),i&&(t._dirty_coords||t.x!==t._x||t.y!==t._y||t.angle!==t._angle||t.scale_x!==t._scale_x||t.scale_y!==t._scale_y)&&t._calculateCoords(),e&&!function(_,t){const n=_._polygon,e=n?0:_.x,s=n?0:_.y,i=n?0:_.radius*_.scale,r=n?_._min_x:e-i,o=n?_._min_y:s-i,h=n?_._max_x:e+i,l=n?_._max_y:s+i,a=t._polygon,c=a?0:t.x,b=a?0:t.y,u=a?0:t.radius*t.scale,v=a?t._min_x:c-u,y=a?t._min_y:b-u,x=a?t._max_x:c+u,d=a?t._max_y:b+u;return r<x&&o<d&&h>v&&l>y}(_,t)||(s&&_._dirty_normals&&_._calculateNormals(),i&&t._dirty_normals&&t._calculateNormals(),r=s&&i?function(_,t,n=null){const e=_._coords.length,s=t._coords.length;if(2===e&&2===s){const e=_._coords,s=t._coords;return n&&(n.overlap=0),e[0]===s[0]&&e[1]===s[1]}const i=_._coords,r=t._coords,o=_._normals,h=t._normals;if(e>2)for(let _=0,t=1;_<e;_+=2,t+=2)if(l(i,r,o[_],o[t],n))return!1;if(s>2)for(let _=0,t=1;_<s;_+=2,t+=2)if(l(i,r,h[_],h[t],n))return!1;return!0}(_,t,n):s?h(_,t,n,!1):i?h(t,_,n,!0):function(_,t,n=null){const e=_.radius*_.scale,s=t.radius*t.scale,i=t.x-_.x,r=t.y-_.y,o=e+s,h=i*i+r*r;if(h>o*o)return!1;if(n){const _=Math.sqrt(h);n.a_in_b=e<=s&&_<=s-e,n.b_in_a=s<=e&&_<=e-s,n.overlap=o-_,n.overlap_x=i/_,n.overlap_y=r/_}return!0}(_,t,n)),n&&(n.collision=r),r}function h(_,t,n=null,e=!1){const s=_._coords,i=_._edges,r=_._normals,o=t.x,h=t.y,l=t.radius*t.scale,a=2*l,c=l*l,b=s.length;let u=!0,v=!0,y=null,x=0,d=0;if(2===b){const _=o-s[0],t=h-s[1],e=_*_+t*t;if(e>c)return!1;if(n){const n=Math.sqrt(e);y=l-n,x=_/n,d=t/n,v=!1}}else for(let _=0,t=1;_<b;_+=2,t+=2){const e=o-s[_],f=h-s[t],m=i[_],p=i[t],g=e*m+f*p,w=g<0?-1:g>m*m+p*p?1:0;let P=!1,M=0,T=0,B=0;if(n&&u&&e*e+f*f>c&&(u=!1),w){const t=-1===w,r=t?0===_?b-2:_-2:_===b-2?0:_+2,a=r+1,u=o-s[r],y=h-s[a],x=i[r],d=i[a],m=u*x+y*d;if((m<0?-1:m>x*x+d*d?1:0)===-w){const _=t?e:u,s=t?f:y,i=_*_+s*s;if(i>c)return!1;if(n){const t=Math.sqrt(i);P=!0,M=l-t,T=_/t,B=s/t,v=!1}}}else{const s=r[_],i=r[t],o=e*s+f*i;if(o>0&&(o<0?-o:o)>l)return!1;n&&(P=!0,M=l-o,T=s,B=i,(v&&o>=0||M<a)&&(v=!1))}P&&(null===y||y>M)&&(y=M,x=T,d=B)}return n&&(n.a_in_b=e?v:u,n.b_in_a=e?u:v,n.overlap=y,n.overlap_x=e?-x:x,n.overlap_y=e?-d:d),!0}function l(_,t,n,e,s=null){const i=_.length,r=t.length;if(!i||!r)return!0;let o=null,h=null,l=null,a=null;for(let t=0,s=1;t<i;t+=2,s+=2){const i=_[t]*n+_[s]*e;(null===o||o>i)&&(o=i),(null===h||h<i)&&(h=i)}for(let _=0,s=1;_<r;_+=2,s+=2){const i=t[_]*n+t[s]*e;(null===l||l>i)&&(l=i),(null===a||a<i)&&(a=i)}if(o>a||h<l)return!0;if(s){let _=0;if(o<l)if(s.a_in_b=!1,h<a)_=h-l,s.b_in_a=!1;else{const t=h-l,n=a-o;_=t<n?t:-n}else if(s.b_in_a=!1,h>a)_=o-a,s.a_in_b=!1;else{const t=h-l,n=a-o;_=t<n?t:-n}const t=s.overlap,i=_<0?-_:_;if(null===t||t>i){const t=_<0?-1:1;s.overlap=i,s.overlap_x=n*t,s.overlap_y=e*t}}return!1}class a{constructor(_=0,t=0,n=0){this.x=_,this.y=t,this.padding=n,this._circle=!1,this._polygon=!1,this._point=!1,this._bvh=null,this._bvh_parent=null,this._bvh_branch=!1,this._bvh_padding=n,this._bvh_min_x=0,this._bvh_min_y=0,this._bvh_max_x=0,this._bvh_max_y=0}collides(_,t=null,n=!0){return o(this,_,t,n)}potentials(){const _=this._bvh;if(null===_)throw new Error("Body does not belong to a collision system");return _.potentials(this)}remove(){const _=this._bvh;_&&_.remove(this,!1)}createResult(){return new r}static createResult(){return new r}}class c extends a{constructor(_=0,t=0,n=0,e=1,s=0){super(_,t,s),this.radius=n,this.scale=e}draw(_){const t=this.x,n=this.y,e=this.radius*this.scale;_.moveTo(t+e,n),_.arc(t,n,e,0,2*Math.PI)}}class b extends a{constructor(_=0,t=0,n=[],e=0,s=1,i=1,r=0){super(_,t,r),this.angle=e,this.scale_x=s,this.scale_y=i,this._polygon=!0,this._x=_,this._y=t,this._angle=e,this._scale_x=s,this._scale_y=i,this._min_x=0,this._min_y=0,this._max_x=0,this._max_y=0,this._points=null,this._coords=null,this._edges=null,this._normals=null,this._dirty_coords=!0,this._dirty_normals=!0,b.prototype.setPoints.call(this,n)}draw(_){(this._dirty_coords||this.x!==this._x||this.y!==this._y||this.angle!==this._angle||this.scale_x!==this._scale_x||this.scale_y!==this._scale_y)&&this._calculateCoords();const t=this._coords;if(2===t.length)_.moveTo(t[0],t[1]),_.arc(t[0],t[1],1,0,2*Math.PI);else{_.moveTo(t[0],t[1]);for(let n=2;n<t.length;n+=2)_.lineTo(t[n],t[n+1]);t.length>4&&_.lineTo(t[0],t[1])}}setPoints(_){const t=_.length;this._points=new Float64Array(2*t),this._coords=new Float64Array(2*t),this._edges=new Float64Array(2*t),this._normals=new Float64Array(2*t);const n=this._points;for(let e=0,s=0,i=1;e<t;++e,s+=2,i+=2){const t=_[e];n[s]=t[0],n[i]=t[1]}this._dirty_coords=!0}_calculateCoords(){const _=this.x,t=this.y,n=this.angle,e=this.scale_x,s=this.scale_y,i=this._points,r=this._coords,o=i.length;let h,l,a,c;for(let b=0,u=1;b<o;b+=2,u+=2){let o=i[b]*e,v=i[u]*s;if(n){const _=Math.cos(n),t=Math.sin(n),e=o;o=e*_-v*t,v=e*t+v*_}o+=_,v+=t,r[b]=o,r[u]=v,0===b?(h=l=o,a=c=v):(o<h?h=o:o>l&&(l=o),v<a?a=v:v>c&&(c=v))}this._x=_,this._y=t,this._angle=n,this._scale_x=e,this._scale_y=s,this._min_x=h,this._min_y=a,this._max_x=l,this._max_y=c,this._dirty_coords=!1,this._dirty_normals=!0}_calculateNormals(){const _=this._coords,t=this._edges,n=this._normals,e=_.length;for(let s=0,i=1;s<e;s+=2,i+=2){const r=s+2<e?s+2:0,o=_[r]-_[s],h=_[r+1]-_[i],l=o||h?Math.sqrt(o*o+h*h):0;t[s]=o,t[i]=h,n[s]=l?h/l:0,n[i]=l?-o/l:0}this._dirty_normals=!1}}class u extends b{constructor(_=0,t=0,n=0){super(_,t,[[0,0]],0,1,1,n),this._point=!0}}u.prototype.setPoints=void 0,n.d(t,"default",function(){return v}),n.d(t,"Collisions",function(){return v}),n.d(t,"Result",function(){return r}),n.d(t,"Circle",function(){return c}),n.d(t,"Polygon",function(){return b}),n.d(t,"Point",function(){return u});class v{constructor(){this._bvh=new i}createCircle(_=0,t=0,n=0,e=1,s=0){const i=new c(_,t,n,e,s);return this._bvh.insert(i),i}createPolygon(_=0,t=0,n=[[0,0]],e=0,s=1,i=1,r=0){const o=new b(_,t,n,e,s,i,r);return this._bvh.insert(o),o}createPoint(_=0,t=0,n=0){const e=new u(_,t,n);return this._bvh.insert(e),e}createResult(){return new r}static createResult(){return new r}insert(..._){for(const t of _)this._bvh.insert(t,!1);return this}remove(..._){for(const t of _)this._bvh.remove(t,!1);return this}update(){return this._bvh.update(),this}draw(_){return this._bvh.draw(_)}drawBVH(_){return this._bvh.drawBVH(_)}potentials(_){return this._bvh.potentials(_)}collides(_,t,n=null,e=!0){return o(_,t,n,e)}}}])});